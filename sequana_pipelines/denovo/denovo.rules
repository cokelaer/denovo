#
#  This file is part of Sequana software
#
#  Copyright (c) 2016-2021 - Sequana Development Team
#
#  File author(s):
#      Dimitri Desvillechabrol <dimitri.desvillechabrol@pasteur.fr>,
#          <d.desvillechabrol@gmail.com>
#
#  Distributed under the terms of the 3-clause BSD license.
#  The full license is in the LICENSE file, distributed with this software.
#
#  website: https://github.com/sequana/sequana
#  documentation: http://sequana.readthedocs.io
#
##############################################################################
"""
Author: Dimitri Desvillechabrol, Thomas Cokelaer
Affiliation: Institut Pasteur
Aim: Denovo assembly
Data: Illumina (short reads)
Run: snakemake -s denovo.rules
"""
import os

from sequana_pipetools import snaketools as sm
from sequana_pipetools.snaketools import PipelineManager
from sequana_pipetools.snaketools import modules


# This must be defined before the include
configfile: "config.yaml"


manager = PipelineManager('denovo', config)

sequana_wrapper_branch = "main"


config = manager.config
__report_dir__ = 'report_{0}'.format(manager.sample)


# Initiate variable that will be modified during the pipeline
__summary_pipeline__outputs = []


__summary_pipeline__json_output = __report_dir__ + "/summary/data.json"
expected_output = []

rule pipeline:
    input: "multiqc/multiqc_report.html", ".sequana/rulegraph.svg"


# ================================================== digital normalisation
#
if config['digital_normalisation']['do']:

    if manager.paired:
        digital_normalisation__output = ["{sample}/digital_normalisation/{sample}_R%i_.dn.fastq" % i for i in (1,2)]
    else:
        digital_normalisation__output = "{sample}/digital_normalisation/{sample}_R1_.dn.fastq"


    rule digital_normalisation:
        input:
            fastq=manager.getrawdata()
        output:
            fastq=digital_normalisation__output
        log:
            "{sample}/digital_normalisation/{sample}.log"
        params:
            prefix = "{sample}/digital_normalisation/{sample}",
            ksize = config['digital_normalisation']['ksize'],
            cutoff = config['digital_normalisation']['cutoff'],
            m = config['digital_normalisation']['max_memory_usage'],
            options = config['digital_normalisation']['options'],
        threads:
            config['digital_normalisation']['threads']
        wrapper:
            f"main/wrappers/digital_normalisation"

    __spades__fastq = digital_normalisation__output
else:
    __spades__fastq = manager.getrawdata()

# ================================================== De Novo Assembly - Spades
#
__spades__outdir = "{sample}/spades"
__spades__contigs = "{sample}/spades/{sample}.contigs.fasta"
__spades__scaffolds = "{sample}/spades/{sample}.scaffolds.fasta"
__spades__log = "{sample}/spades/{sample}.log"
include: sm.modules['spades']

# get corrected reads
if not config['spades']['only_assembler']:
    __spades_get_fastq__input = "{sample}/spades/{sample}.scaffolds.fasta"
    __spades_get_fastq__yaml = __spades__outdir + '/corrected/corrected.yaml'
    __spades_get_fastq__output = [
        "{sample}/spades/{sample}_spades_get_fastq_R1.fastq.gz",
        "{sample}/spades/{sample}_spades_get_fastq_R2.fastq.gz"]
    include: sm.modules['spades_get_fastq']
    __bwa_mem_assembly__fastq = __spades_get_fastq__output
    __summary_pipeline__outputs.append(__spades_get_fastq__output)
else:
    __bwa_mem_assembly__fastq = manager.getrawdata()


# =========================================================== Assembly assessment
#
# - Quast
# - BUSCO
#
__quast__genes = []
if config['quast']['reference']:
    __quast__reference = config['quast']['reference']
    if config['quast']['genes_file']:
        __quast__genes = config['quast']['genes_file']
else:
    __quast__reference = []
__quast__input = [__spades__contigs, "{sample}/spades/{sample}.scaffolds.fasta"]

__quast__outdir = "{sample}/quast"
__quast__done = "{sample}/quast/{sample}.done"
__quast__log = "{sample}/quast/{sample}.log"
include: modules['quast']
expected_output.append(expand(__quast__done, sample=manager.samples))

# reduce names of contigs
__format_contigs__input = "{sample}/spades/{sample}.scaffolds.fasta"
__format_contigs__output = "{sample}/format_contigs/{sample}.fasta"
include: modules['format_contigs']

# ====================================================== Annotation - Prokka
#
if config['prokka']['do']:

    rule prokka:
        priority: 20
        input:
            contigs = __format_contigs__output
        output:
            "{sample}/prokka/{sample}.gbk"
        params:
            config['prokka']['options']
        threads:
            config['prokka']['threads']
        shell:
            """
            prokka {params} --force --cpus {threads} --outdir {wildcards.sample}/prokka --prefix {wildcards.sample} {input.contigs}
            """

    expected_output.append(expand("{sample}/prokka/{sample}.gbk", sample=manager.samples))

# ================================================== Remapping of reads on assembly
#
#  - Variant calling: Freebayes
#  - Coverage analysis: Sequana Coverage
#
# assess de novo quality with coverage analysis and variant calling
__bwa_mem_assembly__reference = __format_contigs__output

rule bwa_index:
    input:
        reference=__format_contigs__output
    output:
        bwa_bwt=__bwa_mem_assembly__reference + '.bwt',
        fai=__bwa_mem_assembly__reference + '.fai'
    log:
        "{sample}/common_logs/bwa_index.log"
    params:
        options="",
        index_algorithm='is'
    threads: 2
    wrapper:
        "main/wrappers/bwa/build"
__bwa_mem_assembly__bam = "{sample}/bwa_mem_assembly/{sample}.sorted.bam"


# ================================================== BWA
rule bwa:
    input:
        fastq=manager.getrawdata(),
        bwa_bwt=__bwa_mem_assembly__reference + '.bwt',
        fai=__bwa_mem_assembly__reference + '.fai',
        reference=__format_contigs__output
    output:
        sorted=__bwa_mem_assembly__bam
    log:
        "{sample}/logs/bwa_mem_assembly.log"
    params:
        options=config["bwa_mem_assembly"]["options"],
        tmp_directory=config["bwa_mem_assembly"]["tmp_directory"]
    threads: 2
    wrapper:
        "main/wrappers/bwa/align"



# =================================================================== sambamba, markdup
# initiate variables
__sambamba_markdup__input = __bwa_mem_assembly__bam
__sambamba_filter__input = __bwa_mem_assembly__bam
__samtools_depth__input = __bwa_mem_assembly__bam
__freebayes__input = __bwa_mem_assembly__bam

# Mark duplicates with sambamba markdup
if config['sambamba_markdup']['do']:
    __sambamba_markdup__output = "{sample}/sambamba_markdup/{sample}.rmdup.sorted.bam"
    __sambamba_markdup__log_err = "{sample}/sambamba_markdup/{sample}_sambamba_markdup.err"
    __sambamba_markdup__log_std = "{sample}/sambamba_markdup/{sample}_sambamba_markdup.std"
    include: modules['sambamba_markdup']
    __sambamba_filter__input = __sambamba_markdup__output
    __freebayes__input = __sambamba_markdup__output
    __samtools_depth__input = __sambamba_markdup__output

# Bam quality filter with sambamba
if config['sambamba_filter']['do']:
    __sambamba_filter__output = "{sample}/sambamba_filter/{sample}.filter.sorted.bam"
    __sambamba_filter__log = "{sample}/sambamba_filter/{sample}.log"
    include: modules['sambamba_filter']
    __freebayes__input = __sambamba_filter__output
    __samtools_depth__input = [__sambamba_filter__output,
                               __sambamba_filter__input]

# ================================================== Sequana_coverage analysis
#
if config['sequana_coverage']['do']:

    rule samtools_depth:
        input:
            __samtools_depth__input
        output:
            "{sample}/samtools_depth/{sample}.bed"
        log:
            "{sample}/samtools_depth/{sample}.log"
        wrapper:
            f"{sequana_wrapper_branch}/wrappers/samtools_depth"

    # this rule has low priority as compared to prokkam that is required but 
    # cannot be an input (in case it is not set ON
    rule sequana_coverage:
        priority: 1
        input: 
            bed="{sample}/samtools_depth/{sample}.bed",
            fasta= __bwa_mem_assembly__reference
        output:
            "{sample}/sequana_coverage/sequana_coverage.html"
        params:
            circular=config["sequana_coverage"]["circular"],
            window_size=config["sequana_coverage"]["window_size"],
            chunksize=config["sequana_coverage"]["chunksize"],
            double_threshold=config["sequana_coverage"]["double_threshold"],
            gc_window_size=config["sequana_coverage"]["gc_window_size"],
            high_threshold=config["sequana_coverage"]["high_threshold"],
            low_threshold=config["sequana_coverage"]["low_threshold"],
            mixture_models=config["sequana_coverage"]["mixture_models"],
            gbk= "{sample}/prokka/{sample}.gbk" if config['prokka']['do'] else None
        wrapper:
            f"{sequana_wrapper_branch}/wrappers/sequana_coverage"

    expected_output += expand("{sample}/sequana_coverage/sequana_coverage.html",
             sample=manager.samples)



# ========================================================= freebayes
# Variant calling with Freebayes
# bai file is setup in freebayes rule for pipeline summary

rule freebayes:
    input:
        bam = __freebayes__input,
        ref= __bwa_mem_assembly__reference
    output:
        "{sample}/freebayes/{sample}.raw.vcf"
    log:
        "{sample}/freebayes/{sample}_freebayes.log"
    params:
        ploidy=config["freebayes"]["ploidy"],
        options=config["freebayes"]["options"]
    wrapper:
        f"{sequana_wrapper_branch}/wrappers/freebayes"

#
rule freebayes_vcf_filter:
    input:
        "{sample}/freebayes/{sample}.raw.vcf"
    output:
        vcf="{sample}/freebayes_vcf_filter/{sample}.filter.vcf",
        csv="{sample}/freebayes_vcf_filter/{sample}.filter.csv",
        html="{sample}/variant_calling.html"
    params:
        filter_dict=config["freebayes_vcf_filter"]
    wrapper:
        f"{sequana_wrapper_branch}/wrappers/freebayes_vcf_filter"

expected_output.append(expand("{sample}/freebayes_vcf_filter/{sample}.filter.vcf",
                               sample=manager.samples))


# ======================================================================= Create rulegraph
sequana_rulegraph_mapper = {'sequana_coverage':'../sequana_coverage.html',
                       'freebayes_vcf_filter':'../variant_calling.html',
                       'quast': '../quast/icarus.html'}
include: sm.modules['rulegraph']

# ======================================================================= summary
# create a json file that summarise information of your pipeline
# they must be complete in the onsuccess block

rule summary:
    input:
        outputs=__summary_pipeline__outputs,
        html=[],
        rulegraph=".sequana/rulegraph.svg",
        snakefile=manager.snakefile,
        config="config.yaml"
    output:
        json= "{sample}/summary/{sample}.json"
    run:
        import json
        import os.path
        summary = {'tool': 'sequana_summary',
                    'inputs':[],
                    'outputs': [],
                    'html': [os.path.realpath(f) for f in input['html']],
                    'rulegraph': os.path.realpath(input['rulegraph']),
                    'requirements': "",
                    'snakefile': os.path.realpath(input['snakefile']),
                     'config': os.path.realpath(input['config']),
                     'name': "variant_calling"}
        js = json.dumps(summary, indent=4, sort_keys=True)
        with open(output['json'], 'w') as fp:
            fp.write(js)

expected_output += expand("{sample}/summary/{sample}.json", sample=manager.samples)

# =============================================================== multiqc

sequana_multiqc_input = expected_output
include: sm.modules['multiqc/2.0']


# these rules don't need to be submit on a node.
localrules: rulegraph, multiqc


onsuccess:
    import os
    import shutil
    import json
    import pandas as pd

    from sequana.utils.datatables_js import DataTable
    from sequana.modules_report.summary import SummaryModule,SummaryModule2
    from sequana.utils import config as conf
    from sequana import logger
    logger.setLevel("INFO")

    # ================================== main HTML report
    # Must be created first because we share the conf and its sections
    manager.clean_multiqc("multiqc/multiqc_report.html")
    intro = """<h2>Overview</h2>
        This pipeline builds denovo assemblies on a set of samples. Individual reports are available
        as well as a <a href="multiqc/multiqc_report.html">multiqc report</a>."""

    intro += "<h2>Individual Reports</h2>"

    # add summary table
    df = pd.DataFrame({"name": sorted(manager.samples)})
    N50s = []
    Ncontigs= []
    for filename in sorted(manager.samples):
        data = open(f"{filename}/quast/report.txt", "r")
        for line in data.readlines():
            if line.startswith(r"# contigs") and ">=" not in line and "Largest" not in line:
                Ncontigs.append(line.split()[2].strip())
            elif line.startswith("N50"):
                N50s.append(line.split()[1].strip())

    df['N50'] = N50s
    df["Ncontig"] = Ncontigs
    df['links'] = [f"{x}/summary.html" for x in df['name']]
    dt = DataTable(df, "stats")
    dt.datatable.datatable_options = {'pageLength': len(manager.samples),
                                       'dom': 'Bfrtip',
                                       'buttons': ['copy', 'csv']}
    dt.datatable.set_links_to_column("links", "name")
    intro +=  dt.create_javascript_function() +  dt.create_datatable()


    data = {"name": "denovo",
            "rulegraph": ".sequana/rulegraph.svg",
            }

    conf.output_dir = os.path.abspath(".")
    s = SummaryModule2(data, intro=intro, workflow=False)

    # create summary pipeline for each samples
    report_dir_format = '{sample}'
    for proj in manager.samples.keys():
        conf.output_dir = proj
        filename = os.sep.join([
            proj,
            'summary',
            'data.json'
        ])

        # ad sub section for variant calling
        if manager.config.freebayes.do:
            conf.summary_sections.append({
                'name': 'sequana coverage',
                'anchor': 'sequana_coverage',
                'content': f'To get information about variants found in your sample, please visit the <a href="variant_calling.html">variant</a> page.'
            })

        # Variant calling
        if manager.config.sequana_coverage.do:
            conf.summary_sections.append({
                'name': 'sequana coverage',
                'anchor': 'sequana_coverage',
                'content': f'The contigs are checked for coverage and reports are available in the <a href="sequana_coverage/sequana_coverage.html">coverage/</a> page.'
            })

        # Prokka section
        if manager.config.prokka.do:
            conf.summary_sections.append({
                'name': 'Prokka',
                'anchor': 'prokka',
                'content': f'Prokka results can be found in <a href="prokka/">prokka/</a> directory where you can find GFF, genbank and other related file ready to use.'
            })

        #quast
        conf.summary_sections.append({
                'name': 'Quast',
                'anchor': 'quast',
                'content': f'The quality assessements can also be investigated using the quast <a href="quast/icarus.html"> reports </a>.'
            })


        SummaryModule(json.loads(open(filename).read()))

    shell("chmod -R g+w .")
    manager.teardown()




onerror:
    from sequana_pipetools.errors import PipeError
    p = PipeError("denovo")
    p.status()


